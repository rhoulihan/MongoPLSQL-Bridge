{
  "version": "1.0",
  "description": "Comprehensive test cases for MongoPLSQL-Bridge operator validation",
  "test_cases": [
    {
      "id": "CMP001",
      "name": "Equality match - string",
      "category": "comparison",
      "operator": "$eq",
      "description": "Tests $eq operator with string field",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "status": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.status') AS status FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' ORDER BY id",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "CMP002",
      "name": "Greater than - numeric",
      "category": "comparison",
      "operator": "$gt",
      "description": "Tests $gt operator with numeric field",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "amount": {
              "$gt": 200
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "amount": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount FROM sales WHERE JSON_VALUE(data, '$.amount' RETURNING NUMBER) > 200 ORDER BY id",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "CMP003",
      "name": "Greater than or equal - numeric",
      "category": "comparison",
      "operator": "$gte",
      "description": "Tests $gte operator with numeric field",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "salary": {
              "$gte": 90000
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "salary": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary FROM employees WHERE JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 90000 ORDER BY id",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "CMP004",
      "name": "Less than - numeric",
      "category": "comparison",
      "operator": "$lt",
      "description": "Tests $lt operator with numeric field",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "price": {
              "$lt": 50
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "price": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products WHERE JSON_VALUE(data, '$.price' RETURNING NUMBER) < 50 ORDER BY id",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "CMP005",
      "name": "Less than or equal - numeric",
      "category": "comparison",
      "operator": "$lte",
      "description": "Tests $lte operator with numeric field",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "yearsOfService": {
              "$lte": 2
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "yearsOfService": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.yearsOfService' RETURNING NUMBER) AS yearsOfService FROM employees WHERE JSON_VALUE(data, '$.yearsOfService' RETURNING NUMBER) <= 2 ORDER BY id",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "CMP006",
      "name": "Not equal - string",
      "category": "comparison",
      "operator": "$ne",
      "description": "Tests $ne operator with string field",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": {
              "$ne": "completed"
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "status": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.status') AS status FROM sales WHERE JSON_VALUE(data, '$.status') <> 'completed' ORDER BY id",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "CMP007",
      "name": "In array - string values",
      "category": "comparison",
      "operator": "$in",
      "description": "Tests $in operator with array of strings",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": {
              "$in": [
                "completed",
                "pending"
              ]
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "status": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.status') AS status FROM sales WHERE JSON_VALUE(data, '$.status') IN ('completed', 'pending') ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "CMP008",
      "name": "Not in array - string values",
      "category": "comparison",
      "operator": "$nin",
      "description": "Tests $nin operator with array of strings",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "region": {
              "$nin": [
                "north",
                "south"
              ]
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "region": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.region') AS region FROM sales WHERE JSON_VALUE(data, '$.region') NOT IN ('north', 'south') ORDER BY id",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "LOG001",
      "name": "Logical AND - two conditions",
      "category": "logical",
      "operator": "$and",
      "description": "Tests $and operator with two conditions",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "$and": [
              {
                "status": "completed"
              },
              {
                "category": "electronics"
              }
            ]
          }
        },
        {
          "$project": {
            "_id": 1,
            "status": 1,
            "category": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.status') AS status, JSON_VALUE(data, '$.category') AS category FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' AND JSON_VALUE(data, '$.category') = 'electronics' ORDER BY id",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "LOG002",
      "name": "Logical AND - three conditions",
      "category": "logical",
      "operator": "$and",
      "description": "Tests $and operator with three conditions",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "$and": [
              {
                "department": "Engineering"
              },
              {
                "active": true
              },
              {
                "salary": {
                  "$gte": 90000
                }
              }
            ]
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1,
            "salary": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.department') AS department, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary FROM employees WHERE JSON_VALUE(data, '$.department') = 'Engineering' AND JSON_VALUE(data, '$.active') = 'true' AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 90000 ORDER BY id",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "LOG003",
      "name": "Logical OR - two conditions",
      "category": "logical",
      "operator": "$or",
      "description": "Tests $or operator with two conditions",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "$or": [
              {
                "status": "cancelled"
              },
              {
                "status": "refunded"
              }
            ]
          }
        },
        {
          "$project": {
            "_id": 1,
            "status": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.status') AS status FROM sales WHERE JSON_VALUE(data, '$.status') = 'cancelled' OR JSON_VALUE(data, '$.status') = 'refunded' ORDER BY id",
      "expected_count": 2,
      "sort_by": "_id"
    },
    {
      "id": "LOG004",
      "name": "Logical OR with AND",
      "category": "logical",
      "operator": "$or/$and",
      "description": "Tests combination of $or and $and operators",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "$or": [
              {
                "department": "Engineering"
              },
              {
                "$and": [
                  {
                    "department": "Sales"
                  },
                  {
                    "active": true
                  }
                ]
              }
            ]
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.department') AS department FROM employees WHERE JSON_VALUE(data, '$.department') = 'Engineering' OR (JSON_VALUE(data, '$.department') = 'Sales' AND JSON_VALUE(data, '$.active') = 'true') ORDER BY id",
      "expected_count": 6,
      "sort_by": "_id"
    },
    {
      "id": "LOG005",
      "name": "Logical NOT",
      "category": "logical",
      "operator": "$not",
      "description": "Tests $not operator",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "price": {
              "$not": {
                "$gt": 100
              }
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "price": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products WHERE NOT (JSON_VALUE(data, '$.price' RETURNING NUMBER) > 100) ORDER BY id",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "AGG001",
      "name": "Group with count",
      "category": "accumulator",
      "operator": "$count",
      "description": "Tests $group with $sum: 1 for counting",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$status",
            "count": {
              "$sum": 1
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.status') AS grp_id, COUNT(*) AS cnt FROM sales GROUP BY JSON_VALUE(data, '$.status') ORDER BY JSON_VALUE(data, '$.status')",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "AGG002",
      "name": "Group with sum",
      "category": "accumulator",
      "operator": "$sum",
      "description": "Tests $group with $sum on numeric field",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$group": {
            "_id": "$category",
            "totalAmount": {
              "$sum": "$amount"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.category') AS grp_id, SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) AS totalAmount FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' GROUP BY JSON_VALUE(data, '$.category') ORDER BY JSON_VALUE(data, '$.category')",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "AGG003",
      "name": "Group with average",
      "category": "accumulator",
      "operator": "$avg",
      "description": "Tests $group with $avg on numeric field",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$department",
            "avgSalary": {
              "$avg": "$salary"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.department') AS grp_id, AVG(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS avgSalary FROM employees GROUP BY JSON_VALUE(data, '$.department') ORDER BY JSON_VALUE(data, '$.department')",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "AGG004",
      "name": "Group with min",
      "category": "accumulator",
      "operator": "$min",
      "description": "Tests $group with $min on numeric field",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$group": {
            "_id": "$category",
            "minPrice": {
              "$min": "$price"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.category') AS grp_id, MIN(JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS minPrice FROM products WHERE JSON_VALUE(data, '$.active') = 'true' GROUP BY JSON_VALUE(data, '$.category') ORDER BY JSON_VALUE(data, '$.category')",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "AGG005",
      "name": "Group with max",
      "category": "accumulator",
      "operator": "$max",
      "description": "Tests $group with $max on numeric field",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$department",
            "maxSalary": {
              "$max": "$salary"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.department') AS grp_id, MAX(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS maxSalary FROM employees GROUP BY JSON_VALUE(data, '$.department') ORDER BY JSON_VALUE(data, '$.department')",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "AGG006",
      "name": "Group with multiple accumulators",
      "category": "accumulator",
      "operator": "$sum/$avg/$min/$max",
      "description": "Tests $group with multiple accumulators",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$department",
            "count": {
              "$sum": 1
            },
            "totalSalary": {
              "$sum": "$salary"
            },
            "avgSalary": {
              "$avg": "$salary"
            },
            "minSalary": {
              "$min": "$salary"
            },
            "maxSalary": {
              "$max": "$salary"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.department') AS grp_id, COUNT(*) AS cnt, SUM(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS totalSalary, AVG(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS avgSalary, MIN(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS minSalary, MAX(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS maxSalary FROM employees GROUP BY JSON_VALUE(data, '$.department') ORDER BY JSON_VALUE(data, '$.department')",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "STG001",
      "name": "Limit results",
      "category": "stage",
      "operator": "$limit",
      "description": "Tests $limit stage",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$sort": {
            "orderId": 1
          }
        },
        {
          "$limit": 3
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId FROM sales ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER) FETCH FIRST 3 ROWS ONLY",
      "expected_count": 3,
      "sort_by": "orderId"
    },
    {
      "id": "STG002",
      "name": "Skip results",
      "category": "stage",
      "operator": "$skip",
      "description": "Tests $skip stage",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$sort": {
            "name": 1
          }
        },
        {
          "$skip": 5
        },
        {
          "$project": {
            "_id": 1,
            "name": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name FROM employees ORDER BY JSON_VALUE(data, '$.name') OFFSET 5 ROWS",
      "expected_count": 5,
      "sort_by": "name"
    },
    {
      "id": "STG003",
      "name": "Skip and limit combined",
      "category": "stage",
      "operator": "$skip/$limit",
      "description": "Tests $skip and $limit stages combined (pagination)",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$sort": {
            "price": -1
          }
        },
        {
          "$skip": 2
        },
        {
          "$limit": 3
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "price": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products ORDER BY JSON_VALUE(data, '$.price' RETURNING NUMBER) DESC OFFSET 2 ROWS FETCH FIRST 3 ROWS ONLY",
      "expected_count": 3,
      "sort_by": null
    },
    {
      "id": "STG004",
      "name": "Sort ascending",
      "category": "stage",
      "operator": "$sort",
      "description": "Tests $sort stage with ascending order",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$sort": {
            "salary": 1
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "salary": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary FROM employees ORDER BY JSON_VALUE(data, '$.salary' RETURNING NUMBER) ASC",
      "expected_count": 10,
      "sort_by": null
    },
    {
      "id": "STG005",
      "name": "Sort descending",
      "category": "stage",
      "operator": "$sort",
      "description": "Tests $sort stage with descending order",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$sort": {
            "price": -1
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "price": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products WHERE JSON_VALUE(data, '$.active') = 'true' ORDER BY JSON_VALUE(data, '$.price' RETURNING NUMBER) DESC",
      "expected_count": 7,
      "sort_by": null
    },
    {
      "id": "STG006",
      "name": "Sort with multiple fields",
      "category": "stage",
      "operator": "$sort",
      "description": "Tests $sort stage with multiple fields",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$sort": {
            "department": 1,
            "salary": -1
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1,
            "salary": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.department') AS department, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary FROM employees ORDER BY JSON_VALUE(data, '$.department') ASC, JSON_VALUE(data, '$.salary' RETURNING NUMBER) DESC",
      "expected_count": 10,
      "sort_by": null
    },
    {
      "id": "STG007",
      "name": "Project include fields",
      "category": "stage",
      "operator": "$project",
      "description": "Tests $project stage with field inclusion",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$project": {
            "orderId": 1,
            "amount": 1,
            "tax": 1,
            "_id": 0
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount, JSON_VALUE(data, '$.tax' RETURNING NUMBER) AS tax FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARITH001",
      "name": "Addition in project",
      "category": "arithmetic",
      "operator": "$add",
      "description": "Tests $add operator in projection",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "total": {
              "$add": [
                "$amount",
                "$tax"
              ]
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, (JSON_VALUE(data, '$.amount' RETURNING NUMBER) + JSON_VALUE(data, '$.tax' RETURNING NUMBER)) AS total FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARITH002",
      "name": "Subtraction in project",
      "category": "arithmetic",
      "operator": "$subtract",
      "description": "Tests $subtract operator in projection",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "profit": {
              "$subtract": [
                "$price",
                "$cost"
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, (JSON_VALUE(data, '$.price' RETURNING NUMBER) - JSON_VALUE(data, '$.cost' RETURNING NUMBER)) AS profit FROM products WHERE JSON_VALUE(data, '$.active') = 'true' ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "ARITH003",
      "name": "Multiplication in project",
      "category": "arithmetic",
      "operator": "$multiply",
      "description": "Tests $multiply operator in projection",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "totalComp": {
              "$add": [
                "$salary",
                {
                  "$multiply": [
                    "$bonus",
                    1
                  ]
                }
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, (JSON_VALUE(data, '$.salary' RETURNING NUMBER) + (JSON_VALUE(data, '$.bonus' RETURNING NUMBER) * 1)) AS totalComp FROM employees ORDER BY id",
      "expected_count": 10,
      "sort_by": "_id"
    },
    {
      "id": "ARITH004",
      "name": "Division in project",
      "category": "arithmetic",
      "operator": "$divide",
      "description": "Tests $divide operator in projection",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "cost": {
              "$gt": 0
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "margin": {
              "$divide": [
                {
                  "$subtract": [
                    "$price",
                    "$cost"
                  ]
                },
                "$cost"
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, ((JSON_VALUE(data, '$.price' RETURNING NUMBER) - JSON_VALUE(data, '$.cost' RETURNING NUMBER)) / JSON_VALUE(data, '$.cost' RETURNING NUMBER)) AS margin FROM products WHERE JSON_VALUE(data, '$.cost' RETURNING NUMBER) > 0 ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "ARITH005",
      "name": "Modulo in project",
      "category": "arithmetic",
      "operator": "$mod",
      "description": "Tests $mod operator in projection",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "orderIdMod3": {
              "$mod": [
                "$orderId",
                3
              ]
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, MOD(JSON_VALUE(data, '$.orderId' RETURNING NUMBER), 3) AS orderIdMod3 FROM sales ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 10,
      "sort_by": "orderId"
    },
    {
      "id": "COND001",
      "name": "Conditional with $cond",
      "category": "conditional",
      "operator": "$cond",
      "description": "Tests $cond operator for conditional logic",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "priceCategory": {
              "$cond": {
                "if": {
                  "$gte": [
                    "$price",
                    100
                  ]
                },
                "then": "expensive",
                "else": "affordable"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, CASE WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 100 THEN 'expensive' ELSE 'affordable' END AS priceCategory FROM products ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "COND002",
      "name": "IfNull handling",
      "category": "conditional",
      "operator": "$ifNull",
      "description": "Tests $ifNull operator for null handling",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "discountApplied": {
              "$ifNull": [
                "$discount",
                0
              ]
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, NVL(JSON_VALUE(data, '$.discount' RETURNING NUMBER), 0) AS discountApplied FROM sales ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 10,
      "sort_by": "orderId"
    },
    {
      "id": "COMPLEX001",
      "name": "Complex pipeline - match, group, sort",
      "category": "complex",
      "operator": "multiple",
      "description": "Tests complex pipeline with multiple stages",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": {
              "$in": [
                "completed",
                "processing"
              ]
            }
          }
        },
        {
          "$group": {
            "_id": "$region",
            "totalSales": {
              "$sum": "$amount"
            },
            "orderCount": {
              "$sum": 1
            }
          }
        },
        {
          "$sort": {
            "totalSales": -1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.region') AS grp_id, SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) AS totalSales, COUNT(*) AS orderCount FROM sales WHERE JSON_VALUE(data, '$.status') IN ('completed', 'processing') GROUP BY JSON_VALUE(data, '$.region') ORDER BY SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) DESC",
      "expected_count": 4,
      "sort_by": null
    },
    {
      "id": "COMPLEX002",
      "name": "Complex pipeline - filter, project, sort, limit",
      "category": "complex",
      "operator": "multiple",
      "description": "Tests complex pipeline with filter, projection, sort, and limit",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1,
            "totalComp": {
              "$add": [
                "$salary",
                "$bonus"
              ]
            }
          }
        },
        {
          "$sort": {
            "totalComp": -1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.department') AS department, (JSON_VALUE(data, '$.salary' RETURNING NUMBER) + JSON_VALUE(data, '$.bonus' RETURNING NUMBER)) AS totalComp FROM employees WHERE JSON_VALUE(data, '$.active') = 'true' ORDER BY (JSON_VALUE(data, '$.salary' RETURNING NUMBER) + JSON_VALUE(data, '$.bonus' RETURNING NUMBER)) DESC FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": null
    },
    {
      "id": "COMPLEX003",
      "name": "Complex pipeline - nested AND/OR",
      "category": "complex",
      "operator": "multiple",
      "description": "Tests complex pipeline with nested logical operators",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "$and": [
              {
                "$or": [
                  {
                    "category": "electronics"
                  },
                  {
                    "category": "jewelry"
                  }
                ]
              },
              {
                "amount": {
                  "$gte": 100
                }
              }
            ]
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "category": 1,
            "amount": 1
          }
        },
        {
          "$sort": {
            "amount": -1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.category') AS category, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount FROM sales WHERE (JSON_VALUE(data, '$.category') = 'electronics' OR JSON_VALUE(data, '$.category') = 'jewelry') AND JSON_VALUE(data, '$.amount' RETURNING NUMBER) >= 100 ORDER BY JSON_VALUE(data, '$.amount' RETURNING NUMBER) DESC",
      "expected_count": 5,
      "sort_by": null
    },
    {
      "id": "EDGE001",
      "name": "Zero values in aggregation",
      "category": "edge",
      "operator": "$sum",
      "description": "Tests aggregation with zero values",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "quantity": 0
          }
        },
        {
          "$group": {
            "_id": null,
            "totalAmount": {
              "$sum": "$amount"
            }
          }
        }
      ],
      "oracle_sql": "SELECT SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) AS totalAmount FROM sales WHERE JSON_VALUE(data, '$.quantity' RETURNING NUMBER) = 0",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "EDGE002",
      "name": "Negative values in aggregation",
      "category": "edge",
      "operator": "$sum",
      "description": "Tests aggregation with negative values",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "amount": {
              "$lt": 0
            }
          }
        },
        {
          "$group": {
            "_id": null,
            "totalRefunds": {
              "$sum": "$amount"
            }
          }
        }
      ],
      "oracle_sql": "SELECT SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) AS totalRefunds FROM sales WHERE JSON_VALUE(data, '$.amount' RETURNING NUMBER) < 0",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "EDGE003",
      "name": "Empty result set",
      "category": "edge",
      "operator": "$match",
      "description": "Tests query that returns no results",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "nonexistent_status"
          }
        },
        {
          "$project": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id FROM sales WHERE JSON_VALUE(data, '$.status') = 'nonexistent_status'",
      "expected_count": 0,
      "sort_by": null
    },
    {
      "id": "STR001",
      "name": "String concatenation",
      "category": "string",
      "operator": "$concat",
      "description": "Tests $concat operator to join strings",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "fullInfo": {
              "$concat": [
                "$name",
                " - ",
                "$department"
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') || ' - ' || JSON_VALUE(data, '$.department') AS fullInfo FROM employees ORDER BY id",
      "expected_count": 10,
      "sort_by": "_id"
    },
    {
      "id": "STR002",
      "name": "String to lowercase",
      "category": "string",
      "operator": "$toLower",
      "description": "Tests $toLower operator",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "deptLower": {
              "$toLower": "$department"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, LOWER(JSON_VALUE(data, '$.department')) AS deptLower FROM employees ORDER BY id",
      "expected_count": 10,
      "sort_by": "_id"
    },
    {
      "id": "STR003",
      "name": "String to uppercase",
      "category": "string",
      "operator": "$toUpper",
      "description": "Tests $toUpper operator",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "nameUpper": {
              "$toUpper": "$name"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, UPPER(JSON_VALUE(data, '$.name')) AS nameUpper FROM products ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "STR004",
      "name": "Substring extraction",
      "category": "string",
      "operator": "$substr",
      "description": "Tests $substr operator to extract part of string",
      "collection": "customers",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "namePrefix": {
              "$substr": [
                "$name",
                0,
                4
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, SUBSTR(JSON_VALUE(data, '$.name'), 1, 4) AS namePrefix FROM customers ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "STR005",
      "name": "String length",
      "category": "string",
      "operator": "$strLenCP",
      "description": "Tests $strLenCP operator to get string length",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "nameLength": {
              "$strLenCP": "$name"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, LENGTH(JSON_VALUE(data, '$.name')) AS nameLength FROM products ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "STR006",
      "name": "String trim",
      "category": "string",
      "operator": "$trim",
      "description": "Tests $trim operator (using existing data)",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "trimmedName": {
              "$trim": {
                "input": "$name"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, TRIM(JSON_VALUE(data, '$.name')) AS trimmedName FROM employees ORDER BY id",
      "expected_count": 10,
      "sort_by": "_id"
    },
    {
      "id": "DATE001",
      "name": "Extract year from date",
      "category": "date",
      "operator": "$year",
      "description": "Tests $year operator to extract year component",
      "collection": "events",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "title": 1,
            "eventYear": {
              "$year": "$eventDate"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.title') AS title, EXTRACT(YEAR FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) AS eventYear FROM events ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "DATE002",
      "name": "Extract month from date",
      "category": "date",
      "operator": "$month",
      "description": "Tests $month operator to extract month component",
      "collection": "events",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "title": 1,
            "eventMonth": {
              "$month": "$eventDate"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.title') AS title, EXTRACT(MONTH FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) AS eventMonth FROM events ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "DATE003",
      "name": "Extract day from date",
      "category": "date",
      "operator": "$dayOfMonth",
      "description": "Tests $dayOfMonth operator to extract day component",
      "collection": "events",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "title": 1,
            "eventDay": {
              "$dayOfMonth": "$eventDate"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.title') AS title, EXTRACT(DAY FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) AS eventDay FROM events ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "DATE004",
      "name": "Extract hour from date",
      "category": "date",
      "operator": "$hour",
      "description": "Tests $hour operator to extract hour component",
      "collection": "events",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "title": 1,
            "eventHour": {
              "$hour": "$eventDate"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.title') AS title, EXTRACT(HOUR FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) AS eventHour FROM events ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "DATE005",
      "name": "Group events by month",
      "category": "date",
      "operator": "$month/$group",
      "description": "Tests $month with $group for monthly aggregation",
      "collection": "events",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": {
              "$month": "$eventDate"
            },
            "eventCount": {
              "$sum": 1
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT EXTRACT(MONTH FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) AS grp_id, COUNT(*) AS eventCount FROM events GROUP BY EXTRACT(MONTH FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"')) ORDER BY EXTRACT(MONTH FROM TO_TIMESTAMP(JSON_VALUE(data, '$.eventDate'), 'YYYY-MM-DD\"T\"HH24:MI:SS.FF3\"Z\"'))",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "ARR001",
      "name": "Get first array element",
      "category": "array",
      "operator": "$arrayElemAt",
      "description": "Tests $arrayElemAt to get first element",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$ne": []
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "firstTag": {
              "$arrayElemAt": [
                "$tags",
                0
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.tags[0]') AS firstTag FROM products WHERE JSON_EXISTS(data, '$.tags[0]') ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "ARR002",
      "name": "Get array size",
      "category": "array",
      "operator": "$size",
      "description": "Tests $size operator to get array length",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "itemCount": {
              "$size": "$items"
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.items.size()' RETURNING NUMBER) AS itemCount FROM sales ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 10,
      "sort_by": "orderId"
    },
    {
      "id": "ARR003",
      "name": "Array first element with $first",
      "category": "array",
      "operator": "$first",
      "description": "Tests $first operator as array accessor",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$ne": []
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "firstTag": {
              "$first": "$tags"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.tags[0]') AS firstTag FROM products WHERE JSON_EXISTS(data, '$.tags[0]') ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "ARR004",
      "name": "Array last element with $last",
      "category": "array",
      "operator": "$last",
      "description": "Tests $last operator as array accessor",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$ne": []
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "lastTag": {
              "$last": "$tags"
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.tags[last]') AS lastTag FROM sales WHERE JSON_EXISTS(data, '$.tags[0]') ORDER BY JSON_VALUE(data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 8,
      "sort_by": "orderId"
    },
    {
      "id": "LOOKUP001",
      "name": "Basic $lookup join",
      "category": "lookup",
      "operator": "$lookup",
      "description": "Tests $lookup stage for basic left outer join",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$lookup": {
            "from": "customers",
            "localField": "customerId",
            "foreignField": "_id",
            "as": "customerInfo"
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "customerTier": {
              "$arrayElemAt": [
                "$customerInfo.tier",
                0
              ]
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT s.id, JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(c.data, '$.tier') AS customerTier FROM sales s LEFT OUTER JOIN customers c ON JSON_VALUE(s.data, '$.customerId') = JSON_VALUE(c.data, '$._id') WHERE JSON_VALUE(s.data, '$.status') = 'completed' ORDER BY JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "LOOKUP002",
      "name": "$lookup with inventory",
      "category": "lookup",
      "operator": "$lookup",
      "description": "Tests $lookup stage joining products with inventory",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$lookup": {
            "from": "inventory",
            "localField": "_id",
            "foreignField": "productId",
            "as": "inventoryRecords"
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "warehouseCount": {
              "$size": "$inventoryRecords"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT p.id, JSON_VALUE(p.data, '$.name') AS name, (SELECT COUNT(*) FROM inventory i WHERE JSON_VALUE(i.data, '$.productId') = JSON_VALUE(p.data, '$._id')) AS warehouseCount FROM products p WHERE JSON_VALUE(p.data, '$.active') = 'true' ORDER BY p.id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "UNWIND001",
      "name": "Basic $unwind array",
      "category": "unwind",
      "operator": "$unwind",
      "description": "Tests $unwind stage to flatten array",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "orderId": 1001
          }
        },
        {
          "$unwind": "$items"
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "product": "$items.product",
            "qty": "$items.qty"
          }
        }
      ],
      "oracle_sql": "SELECT s.id, JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER) AS orderId, jt.product, jt.qty FROM sales s, JSON_TABLE(s.data, '$.items[*]' COLUMNS (product VARCHAR2(100) PATH '$.product', qty NUMBER PATH '$.qty')) jt WHERE JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER) = 1001",
      "expected_count": 2,
      "sort_by": null
    },
    {
      "id": "UNWIND002",
      "name": "$unwind with preserveNullAndEmptyArrays",
      "category": "unwind",
      "operator": "$unwind",
      "description": "Tests $unwind with empty array preservation",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "orderId": {
              "$in": [
                1001,
                1007
              ]
            }
          }
        },
        {
          "$unwind": {
            "path": "$tags",
            "preserveNullAndEmptyArrays": true
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "tag": "$tags"
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT s.id, JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER) AS orderId, jt.tag FROM sales s LEFT OUTER JOIN JSON_TABLE(s.data, '$.tags[*]' COLUMNS (tag VARCHAR2(100) PATH '$')) jt ON 1=1 WHERE JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER) IN (1001, 1007) ORDER BY JSON_VALUE(s.data, '$.orderId' RETURNING NUMBER)",
      "expected_count": 3,
      "sort_by": "orderId"
    },
    {
      "id": "ADDFIELDS001",
      "name": "Add computed field",
      "category": "addFields",
      "operator": "$addFields",
      "description": "Tests $addFields stage to add computed column",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$addFields": {
            "totalCompensation": {
              "$add": [
                "$salary",
                "$bonus"
              ]
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "totalCompensation": 1
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, (JSON_VALUE(data, '$.salary' RETURNING NUMBER) + JSON_VALUE(data, '$.bonus' RETURNING NUMBER)) AS totalCompensation FROM employees ORDER BY id",
      "expected_count": 10,
      "sort_by": "_id"
    },
    {
      "id": "ADDFIELDS002",
      "name": "$set as alias for $addFields",
      "category": "addFields",
      "operator": "$set",
      "description": "Tests $set stage (alias for $addFields)",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$set": {
            "profitMargin": {
              "$subtract": [
                "$price",
                "$cost"
              ]
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "profitMargin": 1
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, (JSON_VALUE(data, '$.price' RETURNING NUMBER) - JSON_VALUE(data, '$.cost' RETURNING NUMBER)) AS profitMargin FROM products WHERE JSON_VALUE(data, '$.active') = 'true' ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "AGG007",
      "name": "Group with $push",
      "category": "accumulator",
      "operator": "$push",
      "description": "Tests $group with $push to collect values into array",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$department",
            "employees": {
              "$push": "$name"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(data, '$.department') AS grp_id, JSON_ARRAYAGG(JSON_VALUE(data, '$.name')) AS employees FROM employees GROUP BY JSON_VALUE(data, '$.department') ORDER BY JSON_VALUE(data, '$.department')",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "AGG008",
      "name": "Group with $addToSet",
      "category": "accumulator",
      "operator": "$addToSet",
      "description": "Tests $group with $addToSet to collect unique values",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$group": {
            "_id": "$region",
            "statuses": {
              "$addToSet": "$status"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT region AS grp_id, JSON_ARRAYAGG(status ORDER BY status) AS statuses FROM (SELECT DISTINCT JSON_VALUE(data, '$.region') AS region, JSON_VALUE(data, '$.status') AS status FROM sales) GROUP BY region ORDER BY region",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "COND003",
      "name": "Nested $cond expressions",
      "category": "conditional",
      "operator": "$cond",
      "description": "Tests nested $cond for multi-branch logic",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "priceRange": {
              "$cond": {
                "if": {
                  "$gte": [
                    "$price",
                    200
                  ]
                },
                "then": "high",
                "else": {
                  "$cond": {
                    "if": {
                      "$gte": [
                        "$price",
                        50
                      ]
                    },
                    "then": "medium",
                    "else": "low"
                  }
                }
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, CASE WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 200 THEN 'high' WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 50 THEN 'medium' ELSE 'low' END AS priceRange FROM products ORDER BY id",
      "expected_count": 8,
      "sort_by": "_id"
    },
    {
      "id": "COMPLEX004",
      "name": "Complex pipeline - lookup with group",
      "category": "complex",
      "operator": "multiple",
      "description": "Tests complex pipeline combining $lookup and $group",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$lookup": {
            "from": "customers",
            "localField": "customerId",
            "foreignField": "_id",
            "as": "customer"
          }
        },
        {
          "$unwind": "$customer"
        },
        {
          "$group": {
            "_id": "$customer.tier",
            "totalAmount": {
              "$sum": "$amount"
            },
            "orderCount": {
              "$sum": 1
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(c.data, '$.tier') AS grp_id, SUM(JSON_VALUE(s.data, '$.amount' RETURNING NUMBER)) AS totalAmount, COUNT(*) AS orderCount FROM sales s INNER JOIN customers c ON JSON_VALUE(s.data, '$.customerId') = JSON_VALUE(c.data, '$._id') WHERE JSON_VALUE(s.data, '$.status') = 'completed' GROUP BY JSON_VALUE(c.data, '$.tier') ORDER BY JSON_VALUE(c.data, '$.tier')",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "COMPLEX005",
      "name": "Complex pipeline - string operations with grouping",
      "category": "complex",
      "operator": "multiple",
      "description": "Tests complex pipeline with string operations and grouping",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$addFields": {
            "deptUpper": {
              "$toUpper": "$department"
            }
          }
        },
        {
          "$group": {
            "_id": "$deptUpper",
            "avgSalary": {
              "$avg": "$salary"
            },
            "headcount": {
              "$sum": 1
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT UPPER(JSON_VALUE(data, '$.department')) AS grp_id, AVG(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS avgSalary, COUNT(*) AS headcount FROM employees GROUP BY UPPER(JSON_VALUE(data, '$.department')) ORDER BY UPPER(JSON_VALUE(data, '$.department'))",
      "expected_count": 4,
      "sort_by": "_id"
    },
    {
      "id": "UNION001",
      "name": "Basic $unionWith - two collections",
      "category": "unionWith",
      "operator": "$unionWith",
      "description": "Tests $unionWith to combine employees and customers (names from both)",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "source": {
              "$literal": "employee"
            }
          }
        },
        {
          "$unionWith": {
            "coll": "customers",
            "pipeline": [
              {
                "$project": {
                  "_id": 1,
                  "name": 1,
                  "source": {
                    "$literal": "customer"
                  }
                }
              }
            ]
          }
        },
        {
          "$sort": {
            "source": 1,
            "name": 1
          }
        },
        {
          "$limit": 10
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, 'employee' AS source FROM employees UNION ALL SELECT id, JSON_VALUE(data, '$.name') AS name, 'customer' AS source FROM customers ORDER BY source, name FETCH FIRST 10 ROWS ONLY",
      "expected_count": 10,
      "sort_by": null
    },
    {
      "id": "UNION002",
      "name": "$unionWith with match filter",
      "category": "unionWith",
      "operator": "$unionWith",
      "description": "Tests $unionWith with $match in sub-pipeline",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$project": {
            "_id": 1,
            "amount": 1,
            "category": 1
          }
        },
        {
          "$unionWith": {
            "coll": "sales",
            "pipeline": [
              {
                "$match": {
                  "status": "pending"
                }
              },
              {
                "$project": {
                  "_id": 1,
                  "amount": 1,
                  "category": 1
                }
              }
            ]
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount, JSON_VALUE(data, '$.category') AS category FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed' UNION ALL SELECT id, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount, JSON_VALUE(data, '$.category') AS category FROM sales WHERE JSON_VALUE(data, '$.status') = 'pending' ORDER BY id",
      "expected_count": 7,
      "sort_by": "_id"
    },
    {
      "id": "UNION003",
      "name": "$unionWith with aggregation",
      "category": "unionWith",
      "operator": "$unionWith",
      "description": "Tests $unionWith followed by group aggregation",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "category": "electronics"
          }
        },
        {
          "$project": {
            "_id": 1,
            "price": 1
          }
        },
        {
          "$unionWith": {
            "coll": "products",
            "pipeline": [
              {
                "$match": {
                  "category": "tools"
                }
              },
              {
                "$project": {
                  "_id": 1,
                  "price": 1
                }
              }
            ]
          }
        },
        {
          "$group": {
            "_id": null,
            "totalProducts": {
              "$sum": 1
            },
            "avgPrice": {
              "$avg": "$price"
            }
          }
        }
      ],
      "oracle_sql": "SELECT COUNT(*) AS totalProducts, AVG(price) AS avgPrice FROM (SELECT JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products WHERE JSON_VALUE(data, '$.category') = 'electronics' UNION ALL SELECT JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM products WHERE JSON_VALUE(data, '$.category') = 'tools')",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "BUCKET001",
      "name": "Basic $bucket - price ranges",
      "category": "bucket",
      "operator": "$bucket",
      "description": "Tests $bucket to group products by price ranges (no default needed - all values covered)",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$bucket": {
            "groupBy": "$price",
            "boundaries": [
              0,
              25,
              100,
              1000
            ],
            "output": {
              "count": {
                "$sum": 1
              },
              "products": {
                "$push": "$name"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT CASE WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 0 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 25 THEN 0 WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 25 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 100 THEN 25 WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 100 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 1000 THEN 100 END AS bucket_id, COUNT(*) AS cnt, JSON_ARRAYAGG(JSON_VALUE(data, '$.name')) AS products FROM products WHERE JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 0 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 1000 GROUP BY CASE WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 0 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 25 THEN 0 WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 25 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 100 THEN 25 WHEN JSON_VALUE(data, '$.price' RETURNING NUMBER) >= 100 AND JSON_VALUE(data, '$.price' RETURNING NUMBER) < 1000 THEN 100 END ORDER BY bucket_id",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "BUCKET002",
      "name": "$bucket - salary bands",
      "category": "bucket",
      "operator": "$bucket",
      "description": "Tests $bucket to group employees by salary bands (all values covered)",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$bucket": {
            "groupBy": "$salary",
            "boundaries": [
              60000,
              75000,
              90000,
              110000
            ],
            "output": {
              "count": {
                "$sum": 1
              },
              "avgBonus": {
                "$avg": "$bonus"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT CASE WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 60000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 75000 THEN 60000 WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 75000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 90000 THEN 75000 WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 90000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 110000 THEN 90000 END AS bucket_id, COUNT(*) AS cnt, AVG(JSON_VALUE(data, '$.bonus' RETURNING NUMBER)) AS avgBonus FROM employees WHERE JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 60000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 110000 GROUP BY CASE WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 60000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 75000 THEN 60000 WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 75000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 90000 THEN 75000 WHEN JSON_VALUE(data, '$.salary' RETURNING NUMBER) >= 90000 AND JSON_VALUE(data, '$.salary' RETURNING NUMBER) < 110000 THEN 90000 END ORDER BY bucket_id",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "BUCKETAUTO001",
      "name": "Basic $bucketAuto - auto price groups",
      "category": "bucketAuto",
      "operator": "$bucketAuto",
      "description": "Tests $bucketAuto to automatically group products by price",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$bucketAuto": {
            "groupBy": "$price",
            "buckets": 3,
            "output": {
              "count": {
                "$sum": 1
              },
              "avgPrice": {
                "$avg": "$price"
              }
            }
          }
        }
      ],
      "oracle_sql": "SELECT bucket_id, COUNT(*) AS cnt, AVG(price) AS avgPrice FROM (SELECT JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price, NTILE(3) OVER (ORDER BY JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS bucket_id FROM products WHERE JSON_VALUE(data, '$.active') = 'true') GROUP BY bucket_id ORDER BY bucket_id",
      "expected_count": 3,
      "sort_by": null
    },
    {
      "id": "BUCKETAUTO002",
      "name": "$bucketAuto - employee salary distribution",
      "category": "bucketAuto",
      "operator": "$bucketAuto",
      "description": "Tests $bucketAuto to distribute employees into salary quartiles",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$bucketAuto": {
            "groupBy": "$salary",
            "buckets": 4,
            "output": {
              "count": {
                "$sum": 1
              },
              "minSalary": {
                "$min": "$salary"
              },
              "maxSalary": {
                "$max": "$salary"
              }
            }
          }
        }
      ],
      "oracle_sql": "SELECT bucket_id, COUNT(*) AS cnt, MIN(salary) AS minSalary, MAX(salary) AS maxSalary FROM (SELECT JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary, NTILE(4) OVER (ORDER BY JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS bucket_id FROM employees) GROUP BY bucket_id ORDER BY bucket_id",
      "expected_count": 4,
      "sort_by": null
    },
    {
      "id": "FACET001",
      "name": "Basic $facet - multiple aggregations",
      "category": "facet",
      "operator": "$facet",
      "description": "Tests $facet for parallel aggregation pipelines",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$facet": {
            "byStatus": [
              {
                "$group": {
                  "_id": "$status",
                  "count": {
                    "$sum": 1
                  }
                }
              },
              {
                "$sort": {
                  "_id": 1
                }
              }
            ],
            "byRegion": [
              {
                "$group": {
                  "_id": "$region",
                  "totalAmount": {
                    "$sum": "$amount"
                  }
                }
              },
              {
                "$sort": {
                  "_id": 1
                }
              }
            ]
          }
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('byStatus' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE status, 'count' VALUE cnt) ORDER BY status) FROM (SELECT JSON_VALUE(data, '$.status') AS status, COUNT(*) AS cnt FROM sales GROUP BY JSON_VALUE(data, '$.status'))), 'byRegion' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE region, 'totalAmount' VALUE totalAmount) ORDER BY region) FROM (SELECT JSON_VALUE(data, '$.region') AS region, SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) AS totalAmount FROM sales GROUP BY JSON_VALUE(data, '$.region')))) AS result FROM DUAL",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "FACET002",
      "name": "$facet - product analysis",
      "category": "facet",
      "operator": "$facet",
      "description": "Tests $facet for multi-faceted product analysis",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$facet": {
            "categorySummary": [
              {
                "$group": {
                  "_id": "$category",
                  "count": {
                    "$sum": 1
                  },
                  "avgPrice": {
                    "$avg": "$price"
                  }
                }
              },
              {
                "$sort": {
                  "_id": 1
                }
              }
            ],
            "priceStats": [
              {
                "$group": {
                  "_id": null,
                  "minPrice": {
                    "$min": "$price"
                  },
                  "maxPrice": {
                    "$max": "$price"
                  },
                  "avgPrice": {
                    "$avg": "$price"
                  }
                }
              }
            ]
          }
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('categorySummary' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE category, 'count' VALUE cnt, 'avgPrice' VALUE avgPrice) ORDER BY category) FROM (SELECT JSON_VALUE(data, '$.category') AS category, COUNT(*) AS cnt, AVG(JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS avgPrice FROM products WHERE JSON_VALUE(data, '$.active') = 'true' GROUP BY JSON_VALUE(data, '$.category'))), 'priceStats' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE NULL, 'minPrice' VALUE minPrice, 'maxPrice' VALUE maxPrice, 'avgPrice' VALUE avgPrice)) FROM (SELECT MIN(JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS minPrice, MAX(JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS maxPrice, AVG(JSON_VALUE(data, '$.price' RETURNING NUMBER)) AS avgPrice FROM products WHERE JSON_VALUE(data, '$.active') = 'true'))) AS result FROM DUAL",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "FACET003",
      "name": "$facet - employee dashboard",
      "category": "facet",
      "operator": "$facet",
      "description": "Tests $facet for employee dashboard with multiple views",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$facet": {
            "departmentCounts": [
              {
                "$group": {
                  "_id": "$department",
                  "count": {
                    "$sum": 1
                  }
                }
              },
              {
                "$sort": {
                  "count": -1
                }
              }
            ],
            "topEarners": [
              {
                "$sort": {
                  "salary": -1
                }
              },
              {
                "$limit": 3
              },
              {
                "$project": {
                  "_id": 1,
                  "name": 1,
                  "salary": 1
                }
              }
            ],
            "totalStats": [
              {
                "$group": {
                  "_id": null,
                  "totalEmployees": {
                    "$sum": 1
                  },
                  "avgSalary": {
                    "$avg": "$salary"
                  },
                  "totalPayroll": {
                    "$sum": "$salary"
                  }
                }
              }
            ]
          }
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('departmentCounts' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE dept, 'count' VALUE cnt) ORDER BY cnt DESC) FROM (SELECT JSON_VALUE(data, '$.department') AS dept, COUNT(*) AS cnt FROM employees GROUP BY JSON_VALUE(data, '$.department'))), 'topEarners' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE id, 'name' VALUE name, 'salary' VALUE salary) ORDER BY salary DESC) FROM (SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary FROM employees ORDER BY JSON_VALUE(data, '$.salary' RETURNING NUMBER) DESC FETCH FIRST 3 ROWS ONLY)), 'totalStats' VALUE (SELECT JSON_ARRAYAGG(JSON_OBJECT('_id' VALUE NULL, 'totalEmployees' VALUE cnt, 'avgSalary' VALUE avgSal, 'totalPayroll' VALUE totalPay)) FROM (SELECT COUNT(*) AS cnt, AVG(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS avgSal, SUM(JSON_VALUE(data, '$.salary' RETURNING NUMBER)) AS totalPay FROM employees))) AS result FROM DUAL",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "WINDOW001",
      "name": "$setWindowFields - rank by salary",
      "category": "setWindowFields",
      "operator": "$setWindowFields",
      "description": "Tests $setWindowFields with $rank partitioned by department",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$setWindowFields": {
            "partitionBy": "$department",
            "sortBy": {
              "salary": -1
            },
            "output": {
              "salaryRank": {
                "$rank": {}
              }
            }
          }
        },
        {
          "$match": {
            "salaryRank": 1
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1,
            "salary": 1,
            "salaryRank": 1
          }
        },
        {
          "$sort": {
            "department": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.department') AS department, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary, salaryRank FROM (SELECT id, data, RANK() OVER (PARTITION BY JSON_VALUE(data, '$.department') ORDER BY JSON_VALUE(data, '$.salary' RETURNING NUMBER) DESC) AS salaryRank FROM employees) WHERE salaryRank = 1 ORDER BY JSON_VALUE(data, '$.department')",
      "expected_count": 4,
      "sort_by": "department"
    },
    {
      "id": "WINDOW002",
      "name": "$setWindowFields - cumulative sum",
      "category": "setWindowFields",
      "operator": "$setWindowFields",
      "description": "Tests $setWindowFields with cumulative $sum",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$setWindowFields": {
            "sortBy": {
              "orderDate": 1
            },
            "output": {
              "runningTotal": {
                "$sum": "$amount",
                "window": {
                  "documents": [
                    "unbounded",
                    "current"
                  ]
                }
              }
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "amount": 1,
            "runningTotal": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.orderId' RETURNING NUMBER) AS orderId, JSON_VALUE(data, '$.amount' RETURNING NUMBER) AS amount, SUM(JSON_VALUE(data, '$.amount' RETURNING NUMBER)) OVER (ORDER BY JSON_VALUE(data, '$.orderDate') ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS runningTotal FROM sales WHERE JSON_VALUE(data, '$.status') = 'completed'",
      "expected_count": 5,
      "sort_by": null
    },
    {
      "id": "WINDOW003",
      "name": "$setWindowFields - document number",
      "category": "setWindowFields",
      "operator": "$setWindowFields",
      "description": "Tests $setWindowFields with $documentNumber",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "active": true
          }
        },
        {
          "$setWindowFields": {
            "partitionBy": "$category",
            "sortBy": {
              "price": -1
            },
            "output": {
              "priceRankInCategory": {
                "$documentNumber": {}
              }
            }
          }
        },
        {
          "$match": {
            "priceRankInCategory": 1
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "category": 1,
            "price": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.category') AS category, JSON_VALUE(data, '$.price' RETURNING NUMBER) AS price FROM (SELECT id, data, ROW_NUMBER() OVER (PARTITION BY JSON_VALUE(data, '$.category') ORDER BY JSON_VALUE(data, '$.price' RETURNING NUMBER) DESC) AS priceRankInCategory FROM products WHERE JSON_VALUE(data, '$.active') = 'true') WHERE priceRankInCategory = 1",
      "expected_count": 3,
      "sort_by": null
    },
    {
      "id": "WINDOW004",
      "name": "$setWindowFields - dense rank",
      "category": "setWindowFields",
      "operator": "$setWindowFields",
      "description": "Tests $setWindowFields with $denseRank",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$setWindowFields": {
            "sortBy": {
              "salary": -1
            },
            "output": {
              "denseRank": {
                "$denseRank": {}
              }
            }
          }
        },
        {
          "$match": {
            "denseRank": {
              "$lte": 3
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "salary": 1,
            "denseRank": 1
          }
        },
        {
          "$sort": {
            "denseRank": 1
          }
        }
      ],
      "oracle_sql": "SELECT id, JSON_VALUE(data, '$.name') AS name, JSON_VALUE(data, '$.salary' RETURNING NUMBER) AS salary, denseRank FROM (SELECT id, data, DENSE_RANK() OVER (ORDER BY JSON_VALUE(data, '$.salary' RETURNING NUMBER) DESC) AS denseRank FROM employees) WHERE denseRank <= 3 ORDER BY denseRank",
      "expected_count": 3,
      "sort_by": "denseRank"
    },
    {
      "id": "TYPE001",
      "name": "$type - get field type",
      "category": "typeConversion",
      "operator": "$type",
      "description": "Tests $type operator to get BSON type of a field",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "statusType": {
              "$type": "$status"
            },
            "amountType": {
              "$type": "$amount"
            }
          }
        },
        {
          "$limit": 3
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", CASE WHEN JSON_VALUE(base.data, '$.status') IS NULL THEN 'null' WHEN JSON_VALUE(base.data, '$.status') IN ('true', 'false') THEN 'bool' WHEN REGEXP_LIKE(JSON_VALUE(base.data, '$.status'), '^-?[0-9]+$') THEN 'int' WHEN REGEXP_LIKE(JSON_VALUE(base.data, '$.status'), '^-?[0-9]+\\.[0-9]+$') THEN 'double' ELSE 'string' END AS statusType, CASE WHEN JSON_VALUE(base.data, '$.amount') IS NULL THEN 'null' WHEN JSON_VALUE(base.data, '$.amount') IN ('true', 'false') THEN 'bool' WHEN REGEXP_LIKE(JSON_VALUE(base.data, '$.amount'), '^-?[0-9]+$') THEN 'int' WHEN REGEXP_LIKE(JSON_VALUE(base.data, '$.amount'), '^-?[0-9]+\\.[0-9]+$') THEN 'double' ELSE 'string' END AS amountType FROM sales base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 3 ROWS ONLY",
      "expected_count": 3,
      "sort_by": "_id"
    },
    {
      "id": "TYPE002",
      "name": "$toInt - convert string to integer",
      "category": "typeConversion",
      "operator": "$toInt",
      "description": "Tests $toInt operator to convert values to integers",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "priceInt": {
              "$toInt": "$price"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, TRUNC(TO_NUMBER(JSON_VALUE(base.data, '$.price'))) AS priceInt FROM products base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "TYPE003",
      "name": "$toString - convert number to string",
      "category": "typeConversion",
      "operator": "$toString",
      "description": "Tests $toString operator to convert values to strings",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "salaryStr": {
              "$toString": "$salary"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, TO_CHAR(JSON_VALUE(base.data, '$.salary')) AS salaryStr FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "TYPE004",
      "name": "$toDouble - convert to double",
      "category": "typeConversion",
      "operator": "$toDouble",
      "description": "Tests $toDouble operator to convert values to doubles",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "priceDouble": {
              "$toDouble": "$price"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, TO_BINARY_DOUBLE(JSON_VALUE(base.data, '$.price')) AS priceDouble FROM products base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "TYPE005",
      "name": "$toBool - convert to boolean",
      "category": "typeConversion",
      "operator": "$toBool",
      "description": "Tests $toBool operator to convert values to booleans",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "isActive": {
              "$toBool": "$active"
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, CASE WHEN JSON_VALUE(base.data, '$.active') IS NULL OR TO_CHAR(JSON_VALUE(base.data, '$.active')) IN ('0', 'false') THEN 'false' ELSE 'true' END AS isActive FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "STR007",
      "name": "$split - split string into array",
      "category": "string",
      "operator": "$split",
      "description": "Tests $split operator to split strings by delimiter",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$addFields": {
            "nameParts": {
              "$split": [
                "$name",
                " "
              ]
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "firstName": {
              "$arrayElemAt": [
                {
                  "$split": [
                    "$name",
                    " "
                  ]
                },
                0
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": null,
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "STR008",
      "name": "$indexOfCP - find substring position",
      "category": "string",
      "operator": "$indexOfCP",
      "description": "Tests $indexOfCP operator to find position of substring",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "aPosition": {
              "$indexOfCP": [
                "$name",
                "a"
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, CASE WHEN INSTR(JSON_VALUE(base.data, '$.name'), :1) = 0 THEN -1 ELSE INSTR(JSON_VALUE(base.data, '$.name'), :2) - 1 END AS aPosition FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "STR009",
      "name": "$regexMatch - regex pattern matching",
      "category": "string",
      "operator": "$regexMatch",
      "description": "Tests $regexMatch operator for pattern matching",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "hasVowelStart": {
              "$regexMatch": {
                "input": "$name",
                "regex": "^[AEIOUaeiou]"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, CASE WHEN REGEXP_LIKE(JSON_VALUE(base.data, '$.name'), :1) THEN 1 ELSE 0 END AS hasVowelStart FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "STR010",
      "name": "$replaceOne - replace first occurrence",
      "category": "string",
      "operator": "$replaceOne",
      "description": "Tests $replaceOne operator to replace first match",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "modifiedDept": {
              "$replaceOne": {
                "input": "$department",
                "find": "Engineering",
                "replacement": "Tech"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, REGEXP_REPLACE(JSON_VALUE(base.data, '$.department'), :1, :2, 1, 1) AS modifiedDept FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "STR011",
      "name": "$replaceAll - replace all occurrences",
      "category": "string",
      "operator": "$replaceAll",
      "description": "Tests $replaceAll operator to replace all matches",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "nameNoSpaces": {
              "$replaceAll": {
                "input": "$name",
                "find": " ",
                "replacement": "_"
              }
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, REGEXP_REPLACE(JSON_VALUE(base.data, '$.name'), :1, :2) AS nameNoSpaces FROM employees base ORDER BY JSON_VALUE(base.data, '$._id') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "ARR005",
      "name": "$filter - filter array elements",
      "category": "array",
      "operator": "$filter",
      "description": "Tests $filter operator to filter array elements by condition",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "highValueItems": {
              "$filter": {
                "input": "$items",
                "as": "item",
                "cond": {
                  "$gt": [
                    "$$item.qty",
                    1
                  ]
                }
              }
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.orderId') AS orderId, (SELECT JSON_ARRAYAGG(val) FROM JSON_TABLE(data, '$.items[*]' COLUMNS (val VARCHAR2(4000) PATH '$')) WHERE JSON_VALUE(base.data, '$.item.qty') > :1) AS highValueItems FROM sales base ORDER BY JSON_VALUE(base.data, '$.orderId') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARR006",
      "name": "$map - transform array elements",
      "category": "array",
      "operator": "$map",
      "description": "Tests $map operator to transform array elements",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "itemProducts": {
              "$map": {
                "input": "$items",
                "as": "item",
                "in": "$$item.product"
              }
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.orderId') AS orderId, (SELECT JSON_ARRAYAGG(JSON_VALUE(base.data, '$.item.product')) FROM JSON_TABLE(data, '$.items[*]' COLUMNS (val VARCHAR2(4000) PATH '$'))) AS itemProducts FROM sales base ORDER BY JSON_VALUE(base.data, '$.orderId') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARR007",
      "name": "$reduce - reduce array to single value",
      "category": "array",
      "operator": "$reduce",
      "description": "Tests $reduce operator to reduce array to single value",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "totalQty": {
              "$reduce": {
                "input": "$items",
                "initialValue": 0,
                "in": {
                  "$add": [
                    "$$value",
                    "$$this.qty"
                  ]
                }
              }
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.orderId') AS orderId, /* $reduce not fully supported */ NULL AS totalQty FROM sales base ORDER BY JSON_VALUE(base.data, '$.orderId') FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARR008",
      "name": "$concatArrays - concatenate arrays",
      "category": "array",
      "operator": "$concatArrays",
      "description": "Tests $concatArrays operator to concatenate multiple arrays",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$exists": true
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "allLabels": {
              "$concatArrays": [
                "$tags",
                [
                  "extra"
                ]
              ]
            }
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": null,
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "ARR009",
      "name": "$slice - get subset of array",
      "category": "array",
      "operator": "$slice",
      "description": "Tests $slice operator to get array subset",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$exists": true
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "firstTwoTags": {
              "$slice": [
                "$tags",
                2
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": null,
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "ARR010",
      "name": "$slice - get last elements",
      "category": "array",
      "operator": "$slice",
      "description": "Tests $slice operator to get last N elements",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$match": {
            "tags": {
              "$exists": true
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "lastTwoTags": {
              "$slice": [
                "$tags",
                -2
              ]
            }
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        },
        {
          "$limit": 5
        }
      ],
      "oracle_sql": null,
      "expected_count": 5,
      "sort_by": "_id"
    },
    {
      "id": "REDACT001",
      "name": "$redact - document level filtering with PRUNE",
      "category": "redact",
      "operator": "$redact",
      "description": "Tests $redact stage to filter documents based on condition",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$redact": {
            "$cond": {
              "if": {
                "$gte": [
                  "$salary",
                  80000
                ]
              },
              "then": "$$KEEP",
              "else": "$$PRUNE"
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "salary": 1
          }
        },
        {
          "$sort": {
            "_id": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, JSON_VALUE(base.data, '$.salary') AS salary FROM employees base WHERE CASE WHEN JSON_VALUE(base.data, '$.salary') >= :1 THEN :2 ELSE :3 END <> :4 ORDER BY JSON_VALUE(base.data, '$._id')",
      "expected_count": 6,
      "sort_by": "_id"
    },
    {
      "id": "REDACT002",
      "name": "$redact - with DESCEND for nested documents",
      "category": "redact",
      "operator": "$redact",
      "description": "Tests $redact stage with DESCEND option",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$redact": {
            "$cond": {
              "if": {
                "$eq": [
                  "$status",
                  "completed"
                ]
              },
              "then": "$$DESCEND",
              "else": "$$PRUNE"
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "orderId": 1,
            "status": 1
          }
        },
        {
          "$sort": {
            "orderId": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.orderId') AS orderId, JSON_VALUE(base.data, '$.status') AS status FROM sales base WHERE CASE WHEN JSON_VALUE(base.data, '$.status') = :1 THEN :2 ELSE :3 END <> :4 ORDER BY JSON_VALUE(base.data, '$.orderId')",
      "expected_count": 5,
      "sort_by": "orderId"
    },
    {
      "id": "SAMPLE001",
      "name": "$sample - random document selection",
      "category": "sample",
      "operator": "$sample",
      "description": "Tests $sample stage to randomly select documents",
      "collection": "products",
      "mongodb_pipeline": [
        {
          "$sample": {
            "size": 3
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name FROM products base ORDER BY DBMS_RANDOM.VALUE FETCH FIRST 3 ROWS ONLY",
      "expected_count": 3,
      "sort_by": null
    },
    {
      "id": "SAMPLE002",
      "name": "$sample - with subsequent processing",
      "category": "sample",
      "operator": "$sample",
      "description": "Tests $sample stage followed by other stages",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$sample": {
            "size": 5
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "department": 1
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, JSON_VALUE(base.data, '$.department') AS department FROM employees base ORDER BY DBMS_RANDOM.VALUE FETCH FIRST 5 ROWS ONLY",
      "expected_count": 5,
      "sort_by": null
    },
    {
      "id": "COUNT001",
      "name": "$count - count all documents",
      "category": "count",
      "operator": "$count",
      "description": "Tests $count stage to count documents",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$count": "totalEmployees"
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('totalEmployees' VALUE COUNT(*)) AS data FROM employees base",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "COUNT002",
      "name": "$count - count after filter",
      "category": "count",
      "operator": "$count",
      "description": "Tests $count stage after $match filter",
      "collection": "sales",
      "mongodb_pipeline": [
        {
          "$match": {
            "status": "completed"
          }
        },
        {
          "$count": "completedOrders"
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('completedOrders' VALUE COUNT(*)) AS data FROM sales base WHERE JSON_VALUE(base.data, '$.status') = :1",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "COUNT003",
      "name": "$count - count with complex filter",
      "category": "count",
      "operator": "$count",
      "description": "Tests $count stage with complex $match conditions",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "$and": [
              {
                "active": true
              },
              {
                "salary": {
                  "$gte": 80000
                }
              }
            ]
          }
        },
        {
          "$count": "highEarningActiveEmployees"
        }
      ],
      "oracle_sql": "SELECT JSON_OBJECT('highEarningActiveEmployees' VALUE COUNT(*)) AS data FROM employees base WHERE (JSON_VALUE(base.data, '$.active') = :1) AND (JSON_VALUE(base.data, '$.salary' RETURNING NUMBER) >= :2)",
      "expected_count": 1,
      "sort_by": null
    },
    {
      "id": "GRAPHLOOKUP001",
      "name": "$graphLookup - with restrictSearchWithMatch",
      "category": "graphLookup",
      "operator": "$graphLookup",
      "description": "Tests $graphLookup with restrictSearchWithMatch filter",
      "collection": "employees",
      "mongodb_pipeline": [
        {
          "$match": {
            "_id": 1
          }
        },
        {
          "$graphLookup": {
            "from": "employees",
            "startWith": "$department",
            "connectFromField": "department",
            "connectToField": "department",
            "as": "colleagues",
            "maxDepth": 0,
            "restrictSearchWithMatch": {
              "active": true
            }
          }
        },
        {
          "$project": {
            "_id": 1,
            "name": 1,
            "colleagueCount": {
              "$size": "$colleagues"
            }
          }
        }
      ],
      "oracle_sql": "SELECT JSON_VALUE(base.data, '$._id') AS \"_id\", JSON_VALUE(base.data, '$.name') AS name, JSON_VALUE(data, '$.colleagues.size()') AS colleagueCount, colleagues_cte.colleagues AS colleagues FROM employees base LEFT OUTER JOIN LATERAL (SELECT JSON_ARRAYAGG(g.data) AS colleagues FROM employees g WHERE JSON_VALUE(g.data, '$.department') = JSON_VALUE(base.data, '$.department') AND JSON_VALUE(g.data, '$.active') = true) colleagues_cte ON 1=1 WHERE JSON_VALUE(base.data, '$._id' RETURNING NUMBER) = :1",
      "expected_count": 1,
      "sort_by": null
    }
  ]
}
